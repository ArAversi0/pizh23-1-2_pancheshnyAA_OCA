# Отчет по лабораторной работе №1
# Введение в алгоритмы. Сложность. Поиск.

**Дата:** 22.09.25
**Семестр:** 3 курс, 5 семестр
**Группа:** ПИЖ-б-о-23-1-2
**Дисциплина:** Оценка сложности алгоритмов
**Студент:** Панчешный Александр Алексеевич

## Цель работы
Освоить понятие вычислительной сложности алгоритма. Получить практические навыки реализации и анализа линейного и бинарного поиска. Научиться экспериментально подтверждать теоретические оценки сложности **O(n)** и **O(log n)**.

## Теоретическая часть
- **Сложность алгоритма**: Характеризует количество ресурсов (времени и памяти), необходимых алгоритму для обработки входных данных объема *n*.  
- **Асимптотический анализ**: Анализ поведения алгоритма при стремлении *n* к бесконечности. Позволяет абстрагироваться от констант и аппаратных особенностей.  
- **O-нотация («О-большое»)**: Верхняя асимптотическая оценка роста функции. Определяет наихудший сценарий работы алгоритма.  
- **Линейный поиск (Linear Search)**: Последовательный перебор всех элементов массива. Сложность: **O(n)**.  
- **Бинарный поиск (Binary Search)**: Поиск в отсортированном массиве путем многократного деления интервала поиска пополам. Сложность: **O(log n)**. Требует предварительной сортировки (**O(n log n)**).

## Практическая часть

### Выполненные задачи
1. Реализовать функцию линейного поиска элемента в массиве.  
2. Реализовать функцию бинарного поиска элемента в отсортированном массиве.  
3. Провести теоретический анализ сложности обоих алгоритмов.  
4. Экспериментально сравнить время выполнения алгоритмов на массивах разного размера.  
5. Визуализировать результаты, подтвердив асимптотику **O(n)** и **O(log n)**.

### Ключевые фрагменты кода
#### Файл main.c
```C
int main() { 
    // Вывод информации о компьютере
    print_pc_info();  // O(1)
    
    // Массив размеров для тестирования
    int sizes[] = {1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000};  // O(1)
    int num_sizes = sizeof(sizes) / sizeof(sizes[0]);  // O(1)
    int iterations = 100;  // O(1)
    int i;  // O(1)
    
    // Массивы для хранения времени выполнения
    double linear_times[num_sizes];   // O(1)
    double binary_times[num_sizes];   // O(1)

    printf("\nЗапуск сравнения алгоритмов поиска...\n");  // O(1)

    // Основной цикл тестирования
    for (i = 0; i < num_sizes; i++) {  // O(num_sizes)
        int size = sizes[i];  // O(1)
        printf("\nТестирование для размера массива: %d\n", size);  // O(1)
        
        // Генерация отсортированного массива
        int* arr = generate_sorted_array(size);  // O(n)
        if (arr == NULL) {
            printf("Ошибка выделения памяти для размера %d\n", size);
            continue;
        }

        // --- ТЕСТЫ ДЛЯ РАЗНЫХ ЦЕЛЕВЫХ ЭЛЕМЕНТОВ ---
        int targets[4];  // O(1)
        targets[0] = arr[0];           // Первый элемент
        targets[1] = arr[size - 1];    // Последний элемент
        targets[2] = arr[size / 2];    // Средний элемент
        targets[3] = -1;               // Отсутствующий элемент (заведомо не входит, т.к. массив содержит только чётные)

        const char* target_names[4] = {
            "первый элемент",
            "последний элемент",
            "средний элемент",
            "отсутствующий элемент"
        };

        double total_linear = 0.0;  // O(1)
        double total_binary = 0.0;  // O(1)

        // Проходим по каждому целевому элементу
        for (int t = 0; t < 4; t++) {  // O(4 * iterations * (n + log n))
            int target = targets[t];  // O(1)

            printf("Цель: %s\n", target_names[t]);  // O(1)

            double l_time = measure_time(linear_search, arr, size, target, iterations);  // O(iterations * n)
            double b_time = measure_time(binary_search, arr, size, target, iterations);  // O(iterations * log n)

            printf("Линейный поиск: %.9f сек\n", l_time);
            printf("Бинарный поиск: %.9f сек\n", b_time);
            printf("Отношение (линейный/бинарный): %.2f\n", l_time / b_time);

            total_linear += l_time;  // O(1)
            total_binary += b_time;  // O(1)
        }

        // Среднее время для данного размера массива по 4 типам целей
        linear_times[i] = total_linear / 4.0;  // O(1)
        binary_times[i] = total_binary / 4.0;  // O(1)

        free(arr);  // O(1)
    }

    // Запись результатов в CSV
    write_to_csv("C:/Users/user/Desktop/Passed/OCA/lab-01/src/data/search.csv",
         sizes, linear_times, binary_times, num_sizes);  // O(num_sizes)
    
    // Вывод теоретической информации
    printf("\nТеоретическая сложность алгоритмов:\n");
    printf("Линейный поиск: O(n)\n");
    printf("Бинарный поиск: O(log n)\n");
    printf("\nРезультаты сохранены в data/search_results.csv\n");
    printf("Рекомендуется использовать Python для построения графиков.\n");

    return 0;  // O(1)
}
```

#### Файл search_comparison.c / Функции поиска
```C
// Функция линейного поиска
int linear_search(int arr[], int size, int target) {
    int i;  // O(1) - объявление переменной
    // O(n) - проход по всем элементам массива
    for (i = 0; i < size; i++) {  // O(n) - цикл по n элементам
        if (arr[i] == target) {  // O(1) - сравнение
            return i;  // O(1) - возврат значения
        }
    }
    return -1;  // O(1) - возврат значения
}
// Общая сложность: O(n)

// Функция бинарного поиска (массив должен быть отсортирован)
int binary_search(int arr[], int size, int target) {
    int left = 0;  // O(1) - инициализация
    int right = size - 1;  // O(1) - инициализация
    int mid;  // O(1) - объявление переменной
    
    // O(log n) - на каждой итерации диапазон уменьшается вдвое
    while (left <= right) {  // O(log n) - цикл выполняется log?(n) раз
        mid = left + (right - left) / 2;  // O(1) - вычисление среднего
        
        if (arr[mid] == target) {  // O(1) - сравнение
            return mid;  // O(1) - возврат значения
        }
        else if (arr[mid] < target) {  // O(1) - сравнение
            left = mid + 1;  // O(1) - присваивание
        }
        else {  // O(1) - ветвление
            right = mid - 1;  // O(1) - присваивание
        }
    }
    return -1;  // O(1) - возврат значения
}
// Общая сложность: O(log n)
```

#### Файл search_comparison.c / Измерение времени поиска
```C
// Функция для измерения времени выполнения поиска
double measure_time(int (*search_func)(int[], int, int), int arr[], int size, int target, int iterations) {
    double total_time;  // O(1) - объявление переменной
    int i;  // O(1) - объявление переменной
    
    // Использование QueryPerformanceCounter для высокоточного измерения времени (аналог time.perf_counter() в Python)
    // Измеряем суммарное время всех итераций сразу для большей точности
    LARGE_INTEGER frequency, start, end;  // O(1) - объявление переменных
    QueryPerformanceFrequency(&frequency);  // O(1) - получение частоты счетчика
    
    // Измеряем время начала всех итераций
    QueryPerformanceCounter(&start);  // O(1) - получение времени начала всех итераций
    
    // O(iterations) - выполнение заданного количества итераций
    for (i = 0; i < iterations; i++) {  // O(iterations) - цикл
        search_func(arr, size, target);  // O(complexity) - вызов функции поиска
    }
    
    // Измеряем время окончания всех итераций
    QueryPerformanceCounter(&end);  // O(1) - получение времени окончания всех итераций
    
    // Вычисляем суммарное время и делим на количество итераций
    total_time = (double)(end.QuadPart - start.QuadPart) / frequency.QuadPart;  // O(1) - вычисление суммарного времени
  
    return total_time / iterations;  // O(1) - возврат среднего значения
}
// Общая сложность: O(iterations * complexity(search_func))
```

#### Файл visualization.py / Графики и выводы
```python
rom pathlib import Path  # O(1)
import pandas as pd       # O(1)
import matplotlib.pyplot as plt  # O(1)
import numpy as np  # O(1)

current_dir = Path(__file__).resolve().parent  # O(1) - получение директории текущего файла
data_path = current_dir.parent / "data" / "search.csv"  # O(1) - построение пути к CSV
report_path = Path("C:/Users/user/Desktop/Passed/OCA/lab-01/report")  # O(1) - путь к папке для сохранения графиков

# Создаём папку report, если её нет
report_path.mkdir(parents=True, exist_ok=True)  # O(1)

# Загружаем данные
try:
    df = pd.read_csv(data_path)  # O(n) - чтение CSV (n = число строк)
    print(f"Данные загружены из: {data_path}")  # O(1) - вывод сообщения
except FileNotFoundError:  # O(1)
    print(f"Файл не найден: {data_path}")  # O(1)
    exit(1)  # O(1)

# Основные переменные
sizes = df["ArraySize"]               # O(n) - извлечение колонки
linear_times = df["LinearSearchTime"] # O(n) - извлечение колонки
binary_times = df["BinarySearchTime"] # O(n) - извлечение колонки

# График 1: обычный масштаб
plt.figure(figsize=(10, 6))            # O(1) - создание фигуры
plt.plot(sizes, linear_times, marker='o', label="Линейный поиск")  # O(n) - построение линии
plt.plot(sizes, binary_times, marker='s', label="Бинарный поиск")  # O(n) - построение линии
plt.xlabel("Размер массива")           # O(1)
plt.ylabel("Время выполнения (сек)")  # O(1)
plt.title("Сравнение алгоритмов поиска")  # O(1)
plt.legend()                           # O(1)
plt.grid(True)                         # O(1)
plt.tight_layout()                      # O(1)
plt.savefig(report_path / "search_plot_linear.png")  # O(1) - сохранение графика
plt.close()                             # O(1) - закрытие фигуры

# График 2: логарифмический масштаб по оси y
plt.figure(figsize=(10, 6))            # O(1)
plt.plot(sizes, linear_times, marker='o', label="Линейный поиск")  # O(n)
plt.plot(sizes, binary_times, marker='s', label="Бинарный поиск")  # O(n)
plt.yscale("log")                       # O(1) - логарифмический масштаб по y
plt.xlabel("Размер массива")            # O(1)
plt.ylabel("Время выполнения (сек)")   # O(1)
plt.title("Сравнение алгоритмов поиска (логарифмический масштаб по y)")  # O(1)
plt.legend()                            # O(1)
plt.grid(True, which="both")            # O(1)
plt.tight_layout()                       # O(1)
plt.savefig(report_path / "search_plot_log.png")  # O(1) - сохранение графика
plt.close()                             # O(1)

# Теоретическая сложность (для сравнения)
# Линейный поиск: O(n)
# Бинарный поиск: O(log n)

# Вычисляем отношение времени линейного поиска к log(n) и бинарного поиска к log(n)
sizes_array = np.array(sizes)           # O(n)
linear_times_array = np.array(linear_times)  # O(n)
binary_times_array = np.array(binary_times)  # O(n)

# Проверяем, как растёт время относительно теории
linear_growth_ratio = linear_times_array / sizes_array         # O(n)
binary_growth_ratio = binary_times_array / np.log2(sizes_array) # O(n)

# Средние значения для оценки
mean_linear_ratio = np.mean(linear_growth_ratio)  # O(n)
mean_binary_ratio = np.mean(binary_growth_ratio)  # O(n)

print(f"Среднее время / O(n) для линейного поиска: {mean_linear_ratio:.2e}")  # O(1)
print(f"Среднее время / O(log n) для бинарного поиска: {mean_binary_ratio:.2e}")  # O(1)

# Интерпретация результатов
print("\nИнтерпретация:")
print("1. Линейный поиск растёт почти пропорционально размеру массива, что соответствует O(n).")
print("2. Бинарный поиск растёт очень медленно с увеличением размера массива, что соответствует O(log n).")
print("3. Расхождения могут быть вызваны:")
print("   - кешированием данных и особенностями работы ОС,")
print("   - случайными колебаниями времени выполнения в коротких интервалах.\n")
```

## Результаты выполнения

### Пример работы программы
```bash
Характеристики ПК для тестирования:
- Процессор: Intel Core i5-12450H
- Видеокарта: Nvidia RTX 4060 8GB 115W
- ОЗУ: 16 GB DDR5
- Накопитель: SSD 1TB
- ОС: Windows 11 Pro
- Компилятор: GCC

Запуск сравнения алгоритмов поиска...

Тестирование для размера массива: 1000
Цель: первый элемент
Линейный поиск: 0.000000008 сек
Бинарный поиск: 0.000000034 сек
Отношение (линейный/бинарный): 0.24
Цель: последний элемент
Линейный поиск: 0.000001263 сек
Бинарный поиск: 0.000000065 сек
Отношение (линейный/бинарный): 19.43
Цель: средний элемент
Линейный поиск: 0.000000652 сек
Бинарный поиск: 0.000000058 сек
Отношение (линейный/бинарный): 11.24
Цель: отсутствующий элемент
Линейный поиск: 0.000001264 сек
Бинарный поиск: 0.000000034 сек
Отношение (линейный/бинарный): 37.18

Тестирование для размера массива: 2000
Цель: первый элемент
Линейный поиск: 0.000000008 сек
Бинарный поиск: 0.000000039 сек
Отношение (линейный/бинарный): 0.21
Цель: последний элемент
Линейный поиск: 0.000002497 сек
Бинарный поиск: 0.000000072 сек
Отношение (линейный/бинарный): 34.68
Цель: средний элемент
Линейный поиск: 0.000001263 сек
Бинарный поиск: 0.000000066 сек
Отношение (линейный/бинарный): 19.14
Цель: отсутствующий элемент
Линейный поиск: 0.000002496 сек
Бинарный поиск: 0.000000037 сек
Отношение (линейный/бинарный): 67.46

Тестирование для размера массива: 5000
Цель: первый элемент
Линейный поиск: 0.000000007 сек
Бинарный поиск: 0.000000056 сек
Отношение (линейный/бинарный): 0.12
Цель: последний элемент
Линейный поиск: 0.000006197 сек
Бинарный поиск: 0.000000087 сек
Отношение (линейный/бинарный): 71.23
Цель: средний элемент
Линейный поиск: 0.000006487 сек
Бинарный поиск: 0.000000081 сек
Отношение (линейный/бинарный): 80.09
Цель: отсутствующий элемент
Линейный поиск: 0.000006202 сек
Бинарный поиск: 0.000000047 сек
Отношение (линейный/бинарный): 131.96

Тестирование для размера массива: 10000
Цель: первый элемент
Линейный поиск: 0.000000007 сек
Бинарный поиск: 0.000000053 сек
Отношение (линейный/бинарный): 0.13
Цель: последний элемент
Линейный поиск: 0.000012547 сек
Бинарный поиск: 0.000000098 сек
Отношение (линейный/бинарный): 128.03
Цель: средний элемент
Линейный поиск: 0.000006202 сек
Бинарный поиск: 0.000000087 сек
Отношение (линейный/бинарный): 71.29
Цель: отсутствующий элемент
Линейный поиск: 0.000019285 сек
Бинарный поиск: 0.000000049 сек
Отношение (линейный/бинарный): 393.57

Тестирование для размера массива: 20000
Цель: первый элемент
Линейный поиск: 0.000000008 сек
Бинарный поиск: 0.000000093 сек
Отношение (линейный/бинарный): 0.09
Цель: последний элемент
Линейный поиск: 0.000034714 сек
Бинарный поиск: 0.000000105 сек
Отношение (линейный/бинарный): 330.61
Цель: средний элемент
Линейный поиск: 0.000018097 сек
Бинарный поиск: 0.000000069 сек
Отношение (линейный/бинарный): 262.28
Цель: отсутствующий элемент
Линейный поиск: 0.000031708 сек
Бинарный поиск: 0.000000054 сек
Отношение (линейный/бинарный): 587.19

Тестирование для размера массива: 50000
Цель: первый элемент
Линейный поиск: 0.000000008 сек
Бинарный поиск: 0.000000059 сек
Отношение (линейный/бинарный): 0.14
Цель: последний элемент
Линейный поиск: 0.000073031 сек
Бинарный поиск: 0.000000113 сек
Отношение (линейный/бинарный): 646.29
Цель: средний элемент
Линейный поиск: 0.000035396 сек
Бинарный поиск: 0.000000104 сек
Отношение (линейный/бинарный): 340.35
Цель: отсутствующий элемент
Линейный поиск: 0.000068787 сек
Бинарный поиск: 0.000000087 сек
Отношение (линейный/бинарный): 790.66

Тестирование для размера массива: 100000
Цель: первый элемент
Линейный поиск: 0.000000008 сек
Бинарный поиск: 0.000000096 сек
Отношение (линейный/бинарный): 0.08
Цель: последний элемент
Линейный поиск: 0.000132252 сек
Бинарный поиск: 0.000000109 сек
Отношение (линейный/бинарный): 1213.32
Цель: средний элемент
Линейный поиск: 0.000075424 сек
Бинарный поиск: 0.000000102 сек
Отношение (линейный/бинарный): 739.45
Цель: отсутствующий элемент
Линейный поиск: 0.000138614 сек
Бинарный поиск: 0.000000065 сек
Отношение (линейный/бинарный): 2132.52

Тестирование для размера массива: 200000
Цель: первый элемент
Линейный поиск: 0.000000007 сек
Бинарный поиск: 0.000000080 сек
Отношение (линейный/бинарный): 0.09
Цель: последний элемент
Линейный поиск: 0.000277844 сек
Бинарный поиск: 0.000000118 сек
Отношение (линейный/бинарный): 2354.61
Цель: средний элемент
Линейный поиск: 0.000134975 сек
Бинарный поиск: 0.000000098 сек
Отношение (линейный/бинарный): 1377.30
Цель: отсутствующий элемент
Линейный поиск: 0.000289736 сек
Бинарный поиск: 0.000000068 сек
Отношение (линейный/бинарный): 4260.82

Тестирование для размера массива: 500000
Цель: первый элемент
Линейный поиск: 0.000000007 сек
Бинарный поиск: 0.000000106 сек
Отношение (линейный/бинарный): 0.07
Цель: последний элемент
Линейный поиск: 0.000674072 сек
Бинарный поиск: 0.000000120 сек
Отношение (линейный/бинарный): 5617.27
Цель: средний элемент
Линейный поиск: 0.000410413 сек
Бинарный поиск: 0.000000114 сек
Отношение (линейный/бинарный): 3600.11
Цель: отсутствующий элемент
Линейный поиск: 0.000750348 сек
Бинарный поиск: 0.000000101 сек
Отношение (линейный/бинарный): 7429.19

Тестирование для размера массива: 1000000
Цель: первый элемент
Линейный поиск: 0.000000008 сек
Бинарный поиск: 0.000000108 сек
Отношение (линейный/бинарный): 0.07
Цель: последний элемент
Линейный поиск: 0.001389571 сек
Бинарный поиск: 0.000000124 сек
Отношение (линейный/бинарный): 11206.22
Цель: средний элемент
Линейный поиск: 0.000733879 сек
Бинарный поиск: 0.000000118 сек
Отношение (линейный/бинарный): 6219.31
Цель: отсутствующий элемент
Линейный поиск: 0.001402189 сек
Бинарный поиск: 0.000000076 сек
Отношение (линейный/бинарный): 18449.86
Данные записаны в C:/Users/user/Desktop/Passed/OCA/lab-01/src/data/search.csv

Теоретическая сложность алгоритмов:
Линейный поиск: O(n)
Бинарный поиск: O(log n)

Результаты сохранены в data/search_results.csv
```

## Выводы
1. Линейный поиск растёт линейно с размером массива, что подтверждает асимптотическую сложность O(n).  
2. Бинарный поиск показывает медленный рост времени выполнения, что соответствует O(log n) и делает его эффективным для больших отсортированных массивов.  
3. Экспериментальные результаты согласуются с теоретическими оценками, небольшие расхождения объясняются особенностями работы памяти и процессора.

## Ответы на контрольные вопросы
1. *Что такое асимптотическая сложность алгоритма и зачем она нужна?* --- **Асимптотическая сложность** характеризует количество ресурсов (времени или памяти), которые потребляет алгоритм при обработке входных данных объёма n. Она нужна для оценки масштабируемости алгоритма и сравнения эффективности разных алгоритмов независимо от конкретного оборудования или реализации.  

2. *Объясните разницу между O(1), O(n) и O(log n). Приведите примеры алгоритмов с такой сложностью.* --- **O(1)** — константная сложность, время выполнения не зависит от размера входных данных (пример: доступ к элементу массива по индексу).  
**O(n)** — линейная сложность, время растёт пропорционально числу элементов (пример: линейный поиск).  
**O(log n)** — логарифмическая сложность, время растёт медленно при увеличении данных, обычно при делении задачи пополам (пример: бинарный поиск в отсортированном массиве).  

3. *В чем основное отличие линейного поиска от бинарного? Какие предварительные условия необходимы для выполнения бинарного поиска?* --- Линейный поиск последовательно перебирает все элементы массива и работает на любых данных. Бинарный поиск делит отсортированный массив пополам на каждом шаге, сокращая диапазон поиска, что делает его быстрее для больших массивов. **Предварительное условие**: массив должен быть отсортирован.  

4. *Почему на практике время выполнения алгоритма может отличаться от теоретической оценки O-большое?* --- Расхождения могут быть вызваны особенностями аппаратного обеспечения (кэш, параллелизм), системой ввода-вывода, оптимизациями компилятора, и случайными колебаниями нагрузки на процессор. O-большое отражает только порядок роста времени, игнорируя константы и накладные расходы.  

5. *Как экспериментально подтвердить, что сложность алгоритма равна O(n) или O(log n)? Опишите план эксперимента.* --- Нужно провести замеры времени выполнения алгоритма на массивах разного размера n, усреднить результаты по нескольким итерациям и построить график зависимости времени от n.  
- Для O(n) график должен быть приблизительно линейным.  
- Для O(log n) график должен расти медленно и логарифмически.  
Сравнение экспериментального графика с теоретической моделью позволяет подтвердить асимптотику.


## Приложения
- [Ссылка на main.c](https://github.com/ArAversi0/pizh23-1-2_pancheshnyAA_OCA/blob/main/lab-01/src/main.c)
- [Ссылка на search_comparison.c](https://github.com/ArAversi0/pizh23-1-2_pancheshnyAA_OCA/blob/main/lab-01/src/modules/search_comparison.c)
- [Ссылка на search_comparison.h](https://github.com/ArAversi0/pizh23-1-2_pancheshnyAA_OCA/blob/main/lab-01/src/modules/search_comparison.h)
- [Ссылка на visualization.py](https://github.com/ArAversi0/pizh23-1-2_pancheshnyAA_OCA/blob/main/lab-01/src/modules/visualization.py)

### Графики
#### График 1: Сравнение времени выполнения в обычном масштабе
![Сравнение алгоритмов поиска](https://github.com/ArAversi0/pizh23-1-2_pancheshnyAA_OCA/blob/main/lab-01/report/search_plot_linear.png)

**Пояснение:**
- Линейный поиск растёт практически линейно с увеличением размера массива, что соответствует теоретической оценке O(n).
- Бинарный поиск остаётся почти постоянным, его время увеличивается очень медленно, что соответствует O(log n).

#### График 2: Сравнение времени выполнения в логарифмическом масштабе по оси y
![Сравнение алгоритмов поиска (логарифмический масштаб по y)](https://github.com/ArAversi0/pizh23-1-2_pancheshnyAA_OCA/blob/main/lab-01/report/search_plot_log.png)

**Пояснение:**
- Линейный поиск на лог-масштабе демонстрирует прямую линию с положительным наклоном, подтверждающую линейный рост.
- Бинарный поиск остаётся почти горизонтальным, визуально подтверждая очень медленный рост времени выполнения и асимптотику O(log n).
