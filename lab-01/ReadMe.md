# Введение в алгоритмы. Сложность. Поиск

## Цель работы
Освоить понятие вычислительной сложности алгоритма. Получить практические навыки реализации и анализа линейного и бинарного поиска. Научиться экспериментально подтверждать теоретические оценки сложности **O(n)** и **O(log n)**.

## Теория (кратко)

- **Сложность алгоритма**: Характеризует количество ресурсов (времени и памяти), необходимых алгоритму для обработки входных данных объема *n*.  
- **Асимптотический анализ**: Анализ поведения алгоритма при стремлении *n* к бесконечности. Позволяет абстрагироваться от констант и аппаратных особенностей.  
- **O-нотация («О-большое»)**: Верхняя асимптотическая оценка роста функции. Определяет наихудший сценарий работы алгоритма.  
- **Линейный поиск (Linear Search)**: Последовательный перебор всех элементов массива. Сложность: **O(n)**.  
- **Бинарный поиск (Binary Search)**: Поиск в отсортированном массиве путем многократного деления интервала поиска пополам. Сложность: **O(log n)**. Требует предварительной сортировки (**O(n log n)**).

## Практика (подробно)

### Задание
1. Реализовать функцию линейного поиска элемента в массиве.  
2. Реализовать функцию бинарного поиска элемента в отсортированном массиве.  
3. Провести теоретический анализ сложности обоих алгоритмов.  
4. Экспериментально сравнить время выполнения алгоритмов на массивах разного размера.  
5. Визуализировать результаты, подтвердив асимптотику **O(n)** и **O(log n)**.

### Шаги выполнения

1. **Создание проекта**  
   Создать файл `search_comparison.py`.  

2. **Реализация алгоритмов**  
   - Реализовать функцию `linear_search(arr, target)`.  
   - Реализовать функцию `binary_search(arr, target)`.  
   - После каждой строки кода в комментарии указать её асимптотическую сложность.  
   - В конце каждой функции указать общую сложность алгоритма.  

3. **Подготовка данных**  
   - Сгенерировать отсортированные массивы целых чисел разного размера (например, `[1000, 2000, 5000, ..., 1000000]`).  
   - Для каждого размера выбрать целевой элемент: первый, последний, средний, отсутствующий.  

4. **Эмпирический анализ производительности**  
   - Написать функцию для замера среднего времени выполнения.  
   - Для каждого размера массива и каждого алгоритма провести серию замеров времени поиска.  
   - **Важно:** все замеры проводить на одной и той же вычислительной машине.  
   - Убедиться, что массив для бинарного поиска отсортирован.  

5. **Визуализация**  
   - Построить на одном графике зависимости времени выполнения от размера массива для обоих алгоритмов.  
   - Построить второй график в логарифмическом масштабе по оси **y** (для наглядного отображения **O(log n)**) или по обеим осям (log-log scale).  

6. **Анализ результатов**  
   - Сравнить теоретические предсказания с практическими результатами.  
   - Объяснить расхождения, если они есть.  

7. **Оформление отчета**  
   - Результаты оформить в файле `README.md` в корне директории с кодом.  
   - Отчет должен содержать цель, теорию, графики, анализ и выводы.  
   - Код должен соответствовать PEP8 и требованиям из `00_lab00-Требования к коду.pdf`.  

8. **Контроль версий**  
   - Стратегия ветвления - GitHub Flow.
