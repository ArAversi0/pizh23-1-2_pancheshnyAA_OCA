# Отчет по лабораторной работе №2
# Основные структуры данных. Анализ и применение

**Дата:** 06.10.25
**Семестр:** 3 курс, 5 семестр
**Группа:** ПИЖ-б-о-23-1-2
**Дисциплина:** Оценка сложности алгоритмов
**Студент:** Панчешный Александр Алексеевич

## Цель работы
Изучить понятие и особенности базовых абстрактных типов данных (стек, очередь, дек,
связный список) и их реализаций в Python. Научиться выбирать оптимальную структуру данных для
решения конкретной задачи, основываясь на анализе теоретической и практической сложности
операций. Получить навыки измерения производительности и применения структур данных для
решения практических задач.

## Теоретическая часть
- **Список (list) в Python**: Реализация динамического массива. Обеспечивает амортизированное
время O(1) для добавления в конец (append). Вставка и удаление в середину имеют сложность
O(n) из-за сдвига элементов. Доступ по индексу - O(1).
- **Связный список (Linked List)**: Абстрактная структура данных, состоящая из узлов, где каждый
узел содержит данные и ссылку на следующий элемент. Вставка и удаление в известное место
(например, начало списка) выполняются за O(1). Доступ по индексу и поиск - O(n). 
- **Стек (Stack)**: Абстрактный тип данных, работающий по принципу LIFO (Last-In-First-Out).
Основные операции: push (добавление, O(1)), pop (удаление с вершины, O(1)), peek (просмотр
вершины, O(1)). В Python может быть реализован на основе списка.
- **Очередь (Queue)**: Абстрактный тип данных, работающий по принципу FIFO (First-In-First-Out).
Основные операции: enqueue (добавление в конец, O(1)), dequeue (удаление из начала, O(1)). В
Python для эффективной реализации используется collections.deque.  
- **Дек (Deque, двусторонняя очередь)**: Абстрактный тип данных, позволяющий добавлять и
удалять элементы как в начало, так и в конец. Все основные операции - O(1). В Python реализован
в классе collections.deque.

## Практическая часть

### Выполненные задачи
1. Реализовать класс `LinkedList` для демонстрации принципов его работы.
2. Используя встроенные типы данных (`list`, `collections.deque`), проанализировать эффективность операций, имитирующих поведение стека, очереди и дека.
3. Провести сравнительный анализ производительности операций для разных структур данных:  
   - `list` vs `LinkedList` для вставки  
   - `list` vs `deque` для очереди
4. Решить 2–3 практические задачи, выбрав оптимальную структуру данных.

### Ключевые фрагменты кода
## Файл linked_list.py
```python
class Node:
    """Узел связного списка. Создание занимает O(1)."""
    def __init__(self, value):
        self.value = value        # O(1)
        self.next = None          # O(1)


class LinkedList:
    """Односвязный список. Все операции указаны с оценками сложности."""

    def __init__(self):
        self.head = None          # O(1)
        self.tail = None          # O(1)
        # Итоговая сложность: O(1)

    def insert_at_start(self, value):
        """Вставка в начало списка — O(1)."""
        new_node = Node(value)    # O(1)
        new_node.next = self.head # O(1)
        self.head = new_node      # O(1)

        if self.tail is None:     # O(1)
            self.tail = new_node  # O(1)
        # Итоговая сложность метода insert_at_start: O(1)

    def insert_at_end(self, value):
        """Вставка в конец списка — O(1)."""
        new_node = Node(value)    # O(1)

        if self.head is None:     # O(1)
            self.head = new_node  # O(1)
            self.tail = new_node  # O(1)
            return                # O(1)

        self.tail.next = new_node # O(1)
        self.tail = new_node      # O(1)
        # Итоговая сложность метода insert_at_end: O(1)

    def delete_from_start(self):
        """Удаление из начала — O(1)."""
        if self.head is None:     # O(1)
            # Итоговая сложность метода delete_from_start: O(1)
            return                # O(1)

        self.head = self.head.next  # O(1)

        if self.head is None:       # O(1)
            self.tail = None        # O(1)
        # Итоговая сложность метода delete_from_start: O(1)

    def traversal(self):
        """Проход по всему списку — O(n)."""
        current = self.head
        while current is not None:           # O(n)
            print(current.value, end=" ")    # O(1)
            current = current.next           # O(1)
        print()                              # O(1)
        # Итоговая сложность метода traversal: O(n)

```

## Файл perfomance_analysis.py
```python
def run_single_insert_test():
    """
    Выполняет практическое сравнение:
    - 1000 вставок в начало list → O(n)
    - 1000 вставок в начало LinkedList → O(1)
    Итоговая сложность: O(n)
    """

    ll = LinkedList()  # O(1)
    ll_time = timeit.timeit(
        stmt="for i in range(1000): ll.insert_at_start(i)",
        globals={"ll": ll},
        number=1
    )  # O(n)

    py_list = []  # O(1)
    list_time = timeit.timeit(
        stmt="for i in range(1000): py_list.insert(0, i)",
        globals={"py_list": py_list},
        number=1
    )  # O(n)

    print("\n=== Практическое сравнение вставки в начало (1000 операций) ===")
    print(f"LinkedList (O(1)):     {ll_time:.6f} сек")
    print(f"Python list (O(n)):    {list_time:.6f} сек")
    print("Теоретически: LinkedList O(1), list.insert(0) O(n)")
    
    # Вычисляем во сколько раз list медленнее LinkedList
    if ll_time > 0:
        ratio = list_time / ll_time
        if ratio >= 1:
            print(f"Разница: list оказался в {ratio:.1f} раз медленнее LinkedList на этой выборке")
        else:
            ratio = 1 / ratio
            print(f"Разница: list оказался в {ratio:.1f} раз быстрее LinkedList на этой выборке")

    # Итоговая сложность функции: O(n)


def run_single_queue_test():
    """
    Сравнение удаления из начала:
    - list.pop(0) — O(n)
    - deque.popleft() — O(1)
    1000 операций.
    Итоговая сложность: O(n)
    """

    lst = [0] * 1000  # O(n)
    dq = deque([0] * 1000)  # O(n)

    lst_time = timeit.timeit(
        stmt="for _ in range(1000): lst.pop(0)",
        globals={"lst": lst},
        number=1
    )  # O(n²)

    dq_time = timeit.timeit(
        stmt="for _ in range(1000): dq.popleft()",
        globals={"dq": dq},
        number=1
    )  # O(n)

    print("\n=== Практическое сравнение удаления из начала (1000 операций) ===")
    print(f"deque (O(1)):          {dq_time:.6f} сек")
    print(f"list pop(0) (O(n)):    {lst_time:.6f} сек")
    print("Теоретически: deque O(1), list.pop(0) O(n)")

    # Вычисляем во сколько раз list медленнее deque
    if dq_time > 0:
        ratio = lst_time / dq_time
        if ratio >= 1:
            print(f"Разница: list оказался в {ratio:.1f} раз медленнее deque на этой выборке")
        else:
            ratio = 1 / ratio
            print(f"Разница: list оказался в {ratio:.1f} раз быстрее deque на этой выборке")

    # Итоговая сложность: O(n)


# Графики

def compare_list_vs_linkedlist():
    """
    Строит графики для разных размеров входа.
    Итоговая сложность: O(sum N)
    """
    sizes = [1000, 2000, 5000, 10000, 20000]  # O(1)
    ll_times = []  # O(1)
    list_times = []  # O(1)

    for n in sizes:  # O(k)
        ll_time = timeit.timeit(
            stmt="for i in range(n): ll.insert_at_start(i)",
            setup="from linked_list import LinkedList; ll = LinkedList()",
            globals={"n": n},
            number=1
        )  # O(n)

        lst_time = timeit.timeit(
            stmt="for i in range(n): arr.insert(0, i)",
            setup="arr=[]",
            globals={"n": n},
            number=1
        )  # O(n²)

        ll_times.append(ll_time)  # O(1)
        list_times.append(lst_time)  # O(1)

    plot_results(
        "list_vs_linkedlist.png",
        sizes,
        ll_times,
        list_times,
        "LinkedList (O(1))",
        "list.insert(0) (O(n))",
        "Сравнение вставки в начало"
    )
    # Итоговая сложность: O(sum N)


def compare_list_vs_deque():
    """
    График удаления из начала list vs deque.
    Итоговая сложность: O(sum N)
    """
    sizes = [1000, 2000, 5000, 10000, 20000]  # O(1)
    deque_times = []  # O(1)
    list_times = []  # O(1)

    for n in sizes:  # O(k)
        dq_time = timeit.timeit(
            stmt="for _ in range(n): dq.popleft()",
            globals={"dq": deque([0] * n), "n": n},
            number=1
        )  # O(n)

        lst_time = timeit.timeit(
            stmt="for _ in range(n): arr.pop(0)",
            globals={"arr": [0] * n, "n": n},
            number=1
        )  # O(n²)

        deque_times.append(dq_time)  # O(1)
        list_times.append(lst_time)  # O(1)

    plot_results(
        "deque_vs_list.png",
        sizes,
        deque_times,
        list_times,
        "deque (O(1))",
        "list.pop(0) (O(n))",
        "Сравнение удаления из начала"
    )
    # Итоговая сложность: O(sum N)

```

## Файл task_solutions.py
```python
def check_brackets(s):
    """
    Проверка сбалансированности скобок.
    Используется стек на списке — операции push/pop O(1).
    Общая сложность: O(n).
    """
    stack = []  # O(1)

    for c in s:  # O(n)
        if c in "([{":           # O(1)
            stack.append(c)      # O(1)
        elif c in ")]}":         # O(1)
            if not stack:        # O(1)
                # Итоговая сложность функции check_brackets: O(n)
                return False     # O(1)

            top = stack.pop()    # O(1)

            if (c == ")" and top != "(") or \
               (c == "]" and top != "[") or \
               (c == "}" and top != "{"):   # O(1)
                # Итоговая сложность функции check_brackets: O(n)
                return False                # O(1)

    # Итоговая сложность функции check_brackets: O(n)
    return len(stack) == 0  # O(1)


def print_queue_simulation():
    """
    Симуляция работы очереди печати.
    deque обеспечивает операции push/pop O(1).
    """
    queue = deque()                  # O(1)
    queue.append("Документ1")        # O(1)
    queue.append("Документ2")        # O(1)
    queue.append("Документ3")        # O(1)

    print("=== Очередь печати ===")
    while queue:                     # O(n)
        print(f"Печатается: {queue.popleft()}")  # popleft — O(1)
    # Итоговая сложность функции print_queue_simulation: O(n)


def is_palindrome(s):
    """
    Проверка, является ли строка палиндромом.
    Используется deque, т.к. pop с обоих концов — O(1).
    Общая сложность: O(n).
    """
    dq = deque()  # O(1)

    for c in s:   # O(n)
        if c.isalnum():                    # O(1)
            dq.append(c.lower())           # O(1)

    while len(dq) > 1:                     # O(n)
        if dq.popleft() != dq.pop():       # каждая операция O(1)
            # Итоговая сложность функции is_palindrome: O(n)
            return False                   # O(1)

    # Итоговая сложность функции is_palindrome: O(n)
    return True  # O(1)

```

## Результаты выполнения

### Пример работы программы
```bash
=== Старт анализа производительности ===

=== Практическое сравнение вставки в начало (1000 операций) ===
LinkedList (O(1)):     0.000629 сек
Python list (O(n)):    0.000359 сек
Теоретически: LinkedList O(1), list.insert(0) O(n)
Разница: list оказался в 1.8 раз быстрее LinkedList на этой выборке

=== Практическое сравнение удаления из начала (1000 операций) ===
deque (O(1)):          0.000057 сек
list pop(0) (O(n)):    0.000159 сек
Теоретически: deque O(1), list.pop(0) O(n)
Разница: list оказался в 2.8 раз медленнее deque на этой выборке

Графики сохранены, тесты завершены.

```

## Выводы
1. Теоретически, вставка элемента в начало LinkedList должна быть быстрее (O(1)), чем у list (O(n)). На практике, при малой выборке в 1000 элементов, list.insert(0) оказался даже быстрее LinkedList (в 1.8 раза). Это связано с особенностями оптимизации Python и малым объёмом данных, где константные накладные расходы на создание узлов и управление ссылками у LinkedList перевешивают асимптотику.  
2. При удалении элементов из начала структуры deque показал явное преимущество над list.pop(0) (2.8 раза быстрее), что полностью соответствует теоретической оценке: deque — O(1), list.pop(0) — O(n). На практике это демонстрирует, что для операций с началом коллекции стоит выбирать структуры с эффективными двусторонними операциями.
3. На короткой дистанции (малое количество элементов) различия в асимптотике могут быть нивелированы накладными расходами реализации, как это наблюдалось с LinkedList. При увеличении количества элементов преимущества структур с лучшей асимптотикой (LinkedList для вставки в начало, deque для удаления с начала) проявятся более явно.
4. Для частого добавления/удаления в начале лучше использовать LinkedList или deque. Для операций доступа по индексу и небольшого числа вставок/удалений на малых объемах данных list остаётся эффективным благодаря внутренней оптимизации Python.

## Ответы на контрольные вопросы

### 1. В чем ключевое отличие динамического массива (list в Python) от связного списка с точки зрения сложности операций вставки в начало и доступа по индексу?

- **Вставка в начало**:  
  - `list` — O(n), потому что все элементы нужно сдвинуть.  
  - `LinkedList` — O(1), достаточно изменить ссылку на новый узел.  
- **Доступ по индексу**:  
  - `list` — O(1), прямой доступ к элементу по индексу.  
  - `LinkedList` — O(n), требуется последовательный обход узлов.

---

### 2. Объясните принцип работы стека (LIFO) и очереди (FIFO). Приведите по два примера их практического использования.

- **Стек (LIFO)** — последний вошёл, первый вышел.  
  - Примеры:  
    1. Функция `undo` в текстовых редакторах.  
    2. Вычисление выражений в обратной польской записи.  

- **Очередь (FIFO)** — первый вошёл, первый вышел.  
  - Примеры:  
    1. Очередь задач на печать.  
    2. Обработка событий в системе реального времени.

---

### 3. Почему операция удаления первого элемента из списка (list) в Python имеет сложность O(n), а из дека (deque) — O(1)?

- В `list` элементы хранятся в массиве, поэтому после удаления первого элемента все последующие сдвигаются на одну позицию — O(n).  
- В `deque` элементы реализованы как двусторонняя очередь, где удаление с начала требует только переназначения ссылки на первый узел — O(1).

---

### 4. Какую структуру данных вы бы выбрали для реализации системы отмены действий (undo) в текстовом редакторе? Обоснуйте свой выбор.

- **Выбор:** стек (`Stack`).  
- **Обоснование:** система undo должна отменять последние действия в обратном порядке (LIFO), что идеально соответствует принципу работы стека.

---

### 5. Замеры показали, что вставка 1000 элементов в начало списка заняла значительно больше времени, чем вставка в начало вашей реализации связного списка. Объясните результаты с точки зрения асимптотической сложности.

- Теоретически `LinkedList` обеспечивает O(1) для вставки в начало, тогда как `list.insert(0)` — O(n).  
- Практический результат может отличаться на малых выборках из-за накладных расходов на управление узлами `LinkedList`.  
- С увеличением объема данных преимущества `LinkedList` станут более заметными, подтверждая теоретическую оценку.

---

## Приложения
- [Ссылка на linked_list.py]()
- [Ссылка на perfomance_analysis.py]()
- [Ссылка на task_solutions.py]()

---

### Графики
#### График 1: Сравнение удаления из начала (deque против list)
![Сравнение удаления из начала]()

#### График 2: Сравнение вставки в начало (python list против linked list)
![Сравнение вставки в начало]()

